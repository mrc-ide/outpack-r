% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/packet.R
\name{outpack_packet_start}
\alias{outpack_packet_start}
\alias{outpack_packet_cancel}
\alias{outpack_packet_end}
\alias{outpack_packet_run}
\alias{outpack_packet_use_dependency}
\alias{outpack_packet_add_custom}
\title{Start, interact with, and end a packet build}
\usage{
outpack_packet_start(
  path,
  name,
  parameters = NULL,
  id = NULL,
  logging_console = NULL,
  logging_threshold = NULL,
  root = NULL
)

outpack_packet_cancel(packet)

outpack_packet_end(packet, insert = TRUE)

outpack_packet_run(packet, script, envir = .GlobalEnv)

outpack_packet_use_dependency(packet, id, files)

outpack_packet_add_custom(packet, application, data, schema = NULL)
}
\arguments{
\item{path}{Path to the build / output directory.}

\item{name}{The name of the packet}

\item{parameters}{Optionally, a named list of parameters.  The
names must be unique, and the values must all be non-NA scalar
atomics (logical, integer, numeric, character)}

\item{id}{The id of an existing packet to use files from}

\item{logging_console}{Optional logical, indicating if we should
override the root's default in logging to the console. A value
of \code{NULL} uses the root value, \code{TRUE} enables console output
even when this is suppressed by the root, and \code{FALSE} disables
it even when this is enabled by the root.}

\item{logging_threshold}{Optional log threshold, indicating if we
override the root's default in logging to the console. A value
of \code{NULL} uses the root value, otherwise use \code{info}, \code{debug} or
\code{trace} (in increasing order of verbosity).}

\item{root}{The outpack root. Will be searched for from the
current directory if not given.}

\item{packet}{A packet object}

\item{insert}{Logical, indicating if we should insert the packet
into the store. This is the default and generally what you
want. The use-case we have for \code{insert = FALSE} is where you
want to write out all metadata after a failure, and in this case
you would not want to do a final insertion into the outpack
archive. When \code{insert = FALSE}, we write out the json metadata
that would have been written as \code{outpack.json} within the packet
working directory.  Note that this skips a lot of validation
(for example, validating that all files exist and that files
marked immutable have not been changed)}

\item{script}{Path to the script within the packet directory (a
relative path).  This function can be safely called multiple
times within a single packet run (or zero times!) as needed.}

\item{envir}{Environment in which to run the script}

\item{files}{A named character vector of files; the name
corresponds to the name within the current packet, while the
value corresponds to the name within the upstream packet}

\item{application}{The name of the application (used to organise
the data and query it later, see Details)}

\item{data}{Additional metadata to add to the packet. This must be
a string representing already-serialised json data.}

\item{schema}{Optionally, but recommended, a schema to validate
\code{data} against.  Validation will only happen if the option
\code{outpack.schema_validate} is \code{TRUE}, as for the main schema
validation.  Will be passed to \link[jsonvalidate:json_schema]{jsonvalidate::json_schema}, so
can be a string containing the schema or a path to the schema.}
}
\value{
Invisibly, a copy of the packet data; this can be passed
as the \code{packet} argument.
}
\description{
Start a packet build (\code{outpack_packet_start}), end one
(\code{outpack_packet_cancel}, \code{outpack_packet_end}) and interact with
one (\code{outpack_packet_use_dependency},
\code{outpack_packet_run})
}
\section{Running scripts}{


R does not make it extremely easy to "run" a script while
collecting output and warnings in a nice way; this is something
you may be familiar with when running scripts through things
like knitr where differences in behaviour between running from
within knitr and R are not uncommon.  If you see any behaviour
which feels very different to what you expect please let us
know.

One area of known difference is that of warnings; what R does with
warnings depends on a number of options - both global and to
\code{warning} itself. We do not try very hard currently to get the
same behaviour with warnings as you might see running directly
with \code{source} and observing your terminal, partly because we
hope that in practice your code will produce very few warnings.

On failure in the script, \code{outpack_packet_run} will throw, forcing
any function that calls \code{outpack_packet_run} to explicitly cope
with error. The error that is generated will have class
\code{outpack_packet_run_error} allowing this error to be easily
distinguished from other R errors. It will have, in addition to
a \code{message} field, additional data fields containing information
about the error:
\itemize{
\item \code{error}: the original error object, as thrown and caught by \code{outpack}
\item \code{trace}: the backtrace for the above error, currently just as a
character vector, though this may change in future versions
\item \code{output}: a character vector of interleaved stdout and stderr as
the script ran
\item \code{warnings}: a list of warnings raised by the script
}

The other reason why the script may fail is that it fails to
balance one of the global resource stacks - either connections
(rare) or graphics devices (easy to do). In this case, we still
throw a (classed) error, but the \code{error} field in the final
error will be \code{NULL}, with an informative message explaining
what was not balanced.
}

\section{Custom metadata}{


The \code{outpack_packet_add_custom} function adds arbitrary
additional metadata into a packet. It is primarily designed for
use with applications that build on outpack to provide
additional information beyond the minimal set provided by
outpack.

For example, orderly tracks "artefacts" which collect groups of
file outputs into logical bundles.  To support this it needs to
register additional data for each artefact with:
\itemize{
\item the description of the artefect (a short phrase)
\item the format of the artefact (a string describing the data type)
\item the contents of the artefact (an array of filenames)
}

JSON for this might look like:

\if{html}{\out{<div class="sourceCode json">}}\preformatted{\{
  "artefacts": [
    \{
      "description": "Data for onward use",
      "format": "data",
      "contents": ["results.rds", "summary.rds"]
    \},
    \{
      "description": "Diagnostic figures",
      "format": "staticgraph",
      "contents": ["fits.png", "inputs.png"]
    \}
  ]
\}
}\if{html}{\out{</div>}}

Here, we describe two artefacts, together collecting four files.

We need to store these in outpack's final metadata, and we want to
do this in a way that allows easy querying later on while
scoping the data to your application.  To allow for this we
group all data your application adds under an application key
(e.g., \code{orderly}).  You can then store whatever data you want
beneath this key.

\strong{NOTE1}: A limitation here is that the filenames above cannot be
checked against the outpack list of files because outpack does
not know that \code{contents} here refers to filenames.

\strong{NOTE2}: To allow for predictable serialisation to JSON, you
must serialise your own data before passing through to
\code{outpack_packet_add_custom}.
}

